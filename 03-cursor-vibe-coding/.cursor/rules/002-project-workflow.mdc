---
description: 
globs: 
alwaysApply: true
---
# 프론트엔드 개발 워크플로우 (Enhanced)

## 기본 원칙
- Phase 1이 명확하지 않으면 사용자에게 되물어서 명확한 계획을 완성
- **구현 전 사용자 확인**: Phase 1 완료 후 반드시 사용자에게 구현 계획을 확인받고 승인 후 Phase 2 진행
- Planning은 여러번 반복 가능하며, '구현' 또는 'act' 명령 시 구현 단계로 진입
- Linear Task 완료 시 내용을 정리하여 해당 Task에 Comment 작성
- 각 단계별 검증을 통해 다음 단계로 진행하며, 필요시 이전 단계로 피드백
- 반드시 위 원칙을 준수하여 개발 진행

---

## 📋 Phase 1: 상황 인지 & 계획 수립 (Enhanced Top-down)

### 1. 요구사항 분석
- **작업 유형 분류**: Bugfix / Feature / Enhancement / Refactor / UI/UX
- **비즈니스 로직 이해**: 도메인 지식 및 사용자 시나리오 파악
- **우선순위 설정**: 핵심 기능 vs 부가 기능, 필수 vs 선택사항 구분
- **제약사항 확인**: 기술적/비기능적 요구사항, 일정 및 리소스 제약
- **참고 자료 수집**: 기존 유사 기능 및 재사용 가능한 컴포넌트 확인

### 2. 영향도 세부 분석 (Enhanced)
- **관련 컴포넌트 식별**:
  - 직접 영향: 수정 대상 컴포넌트 및 직접 연결된 컴포넌트
  - 간접 영향: 상태 공유, props 전달, context 사용 컴포넌트
  - 사이드 이펙트 가능 영역: 성능, 접근성, 보안에 영향받는 컴포넌트
- **이벤트 전파 경로 분석**:
  - 사용자 액션 → 이벤트 핸들러 → 상태 변경 → UI 업데이트 플로우
  - Electron IPC 이벤트 → 메인 프로세스 → 렌더러 프로세스 통신
  - 라우트 변경, 브라우저 이벤트 등 시스템 이벤트 영향
- **상태 전파 경로 분석**: 
  - Zustand 스토어 → 구독 컴포넌트 → 하위 컴포넌트 체인 확인
  - 전역 상태 vs 로컬 상태 영향 범위 파악
  - 상태 변경 시 리렌더링 범위 예측

### 3. 아키텍처 매핑 & 설계
- **FSD 계층 매핑**: app → pages → widgets → features → entities → shared
- **의존성 검증**: 상위 계층 → 하위 계층 방향 import 규칙 준수 확인
- **컴포넌트 재사용성**: shared 계층 우선 활용, 중복 방지 전략
- **책임 분리**: 각 계층별 역할과 책임 명확화
- **확장성 고려**: 향후 기능 추가 시 구조적 확장 가능성 검토

### 4. 상태 관리 & 인터페이스 설계
- **상태 범위 결정**: Local State vs Global State(Zustand) 구분 기준
- **스토어 구조 설계**: 전역 스토어 vs 엔티티별 스토어 분리 전략
- **데이터 흐름 정의**: User Action → Event Handler → State Update → UI Update
- **타입 정의**: TypeScript Interface, API Schema, 이벤트 타입 설계
- **에러/로딩 상태**: 비동기 작업에 대한 상태 관리 및 사용자 피드백 전략

### 5. 필요 소스코드 파악
- **신규 생성 파일**: 
  - 컴포넌트: 어떤 계층에 어떤 컴포넌트가 필요한지
  - 스토어: 새로운 상태 관리가 필요한 영역
  - 타입: 새로운 인터페이스 및 타입 정의
  - 유틸리티: 공통 함수 및 헬퍼 함수
- **수정 대상 파일**: 
  - 기존 컴포넌트 중 변경이 필요한 부분과 변경 범위
  - 라우팅, 스토어, 타입 정의 수정사항
- **의존성 변경**: package.json, import 구조, 설정 파일 변경사항

### 6. 사용자 확인 단계 ⚠️
- **구현 계획 요약**: Phase 1에서 수립한 모든 계획을 명확히 요약
- **사용자 승인 요청**: "위 계획으로 구현을 진행해도 될까요?" 형태로 명시적 확인
- **승인 후 진행**: 사용자 승인 후에만 Phase 2로 진행

---

## 🔧 Phase 2: 구현 (Enhanced Bottom-up)

### 1. UI 구현 (Bottom-up 시작)
- **Atomic UI**: shared/ui의 기본 UI 요소 (Button, Input, Modal 등)
  - 시각적 디자인: 레이아웃, 색상, 타이포그래피, 애니메이션
  - 접근성 고려: ARIA 속성, 키보드 네비게이션, 포커스 관리
  - 반응형 디자인: 다양한 화면 크기 대응
  - 스타일링: Tailwind CSS 기반 스타일링
- **Entity UI**: 도메인 특화 UI 요소 (Agent Card, Task Item 등)
  - 비즈니스 도메인에 특화된 시각적 표현
  - 데이터 표시 형식 및 레이아웃 구조
  - 도메인별 인터랙션 패턴
- **Feature UI**: 기능별 UI 조합 (Agent Builder, Task Manager 등)
  - 복합 UI 블록의 시각적 구성
  - 사용자 워크플로우에 맞는 UI 배치
  - 기능별 특화된 인터페이스 디자인

### 2. 이벤트 구현 (UI에 생명력 부여)
- **UI 이벤트 핸들러**: 각 UI 요소별 인터랙션 로직
  - 클릭, 호버, 포커스, 블러 등 기본 이벤트
  - 드래그 앤 드롭, 제스처, 키보드 단축키
  - 폼 검증, 제출, 리셋 로직
  - 실시간 검색, 자동완성, 필터링
- **시스템 이벤트**: UI와 시스템 간 연결점
  - Electron IPC 통신 (파일 시스템, 네이티브 API)
  - 라우트 변경, 브라우저 이벤트 (resize, beforeunload)
  - 웹소켓, SSE 등 실시간 통신 이벤트
- **이벤트 최적화**: 성능과 사용자 경험 고려
  - 디바운싱, 스로틀링 적용
  - 이벤트 위임 및 메모리 누수 방지
  - 에러 바운더리 및 예외 처리

### 3. 상태 연동 & 컴포넌트 완성 (UI + Event + State)
- **스토어 연결**: UI와 상태 관리 시스템 연동
  - Zustand 스토어와 컴포넌트 연결
  - 상태 구독 및 업데이트 로직
  - 로컬 상태 vs 전역 상태 적절한 활용
- **데이터 바인딩**: UI 요소와 데이터 동기화
  - Props 전달 및 상태 끌어올리기
  - 양방향 데이터 바인딩 (폼 입력 등)
  - 조건부 렌더링 및 리스트 렌더링
- **상태 동기화**: 컴포넌트 간 일관성 보장
  - 여러 컴포넌트 간 상태 일관성 보장
  - 낙관적 업데이트 vs 비관적 업데이트 전략
  - 상태 영속화 (localStorage, sessionStorage)
- **컴포넌트 완성**: UI + Event + State 통합
  - 타입 안전성: Props 인터페이스 정의, 제네릭 활용
  - 에러 바운더리: 컴포넌트 레벨 에러 처리
  - 성능 최적화: React.memo, useMemo, useCallback 적용

### 4. Widget & Page 조합
- **Widget 컴포넌트**: 복합 UI 블록, 페이지 섹션 단위 컴포넌트
- **Page 컴포넌트**: 라우트별 페이지 컴포넌트 및 레이아웃
- **라우팅 연결**: React Router 설정, 네비게이션 가드, 동적 라우팅
- **레이아웃 시스템**: 헤더, 사이드바, 메인 콘텐츠 영역 구성
- **로딩 상태**: 페이지 레벨 로딩, 스켈레톤 UI, 프로그레스 바

### 5. 사이드 이펙트 파악 & 대응
- **성능 영향 분석**:
  - 리렌더링 최적화: React.memo, useMemo, useCallback 적용
- **상태 일관성 검증**:
  - 동시성 문제: Race condition, 상태 충돌 해결
  - 데이터 무결성: 낙관적 업데이트 실패 시 롤백 전략
  - 캐시 무효화: 상태 변경 시 관련 캐시 업데이트

### 6. 리팩토링 & 최적화
- **코드 품질 개선**:
  - 중복 코드 제거: 공통 로직 추출, 커스텀 훅 활용
  - 복잡도 감소: 함수 분리, 조건부 렌더링 최적화
  - 가독성 향상: 명명 규칙, 주석, 문서화
- **성능 최적화**:
  - 렌더링 최적화: 가상화, 지연 로딩, 이미지 최적화
  - 네트워크 최적화: 요청 배칭, 캐싱 전략, 압축
  - 메모리 최적화: 객체 풀링, 가비지 컬렉션 고려
- **타입 안전성 강화**:
  - any 타입 제거: 구체적인 타입 정의, 타입 가드 활용
  - 제네릭 활용: 재사용 가능한 타입 정의
  - 런타임 검증: Zod, Yup 등을 활용한 스키마 검증

---

## 💡 핵심 체크포인트 (Enhanced)

### Phase 1 완료 기준
- [ ] 현재 코드베이스 상황이 명확히 파악됨
- [ ] 모든 요구사항이 구체적으로 정의됨
- [ ] 상태/이벤트 전파 경로가 설계됨
- [ ] 영향받는 모든 컴포넌트가 식별됨
- [ ] FSD 아키텍처 계층 구조가 설계됨
- [ ] 필요한 모든 소스코드가 파악됨
- [ ] 예상 사이드 이펙트가 분석됨
- [ ] **사용자 승인 완료** ⚠️

### Phase 2 완료 기준
- [ ] 모든 컴포넌트가 FSD 규칙을 준수함
- [ ] 타입 안전성이 보장됨 (any 타입 0개)
- [ ] 상태 관리가 올바르게 동작함
- [ ] 모든 이벤트가 정상 처리됨
- [ ] 사이드 이펙트가 적절히 처리됨
- [ ] 성능 최적화가 적용됨
- [ ] 접근성 기준을 충족함
- [ ] 보안 요구사항을 만족함
- [ ] 테스트 코드가 작성됨

### 단계별 검증 포인트
- **Phase 1 완료 시**: 사용자 승인 후 Phase 2 진행
- **Phase 2 완료 시**: 체크리스트 확인 후 Phase 3 진행
- **문제 발견 시**: 이전 단계로 피드백하여 수정

---

## 🔄 품질 관리 & 지속적 개선

### 코드 리뷰 필수 항목
- [ ] FSD 아키텍처 준수 여부
- [ ] TypeScript 타입 안전성
- [ ] 성능 최적화 적용 상태
- [ ] 에러 처리 완성도

### 리팩토링 트리거
- 코드 중복 3회 이상 발생 시
- 컴포넌트 복잡도 임계치 초과 시
- 성능 이슈 발생 시 (렌더링 > 16ms)
- 유지보수성 저하 시 (수정 시간 > 예상 시간 2배)
- 타입 에러 빈발 시

### 지속적 개선
- **회고**: 각 기능 완료 후 워크플로우 개선점 도출
- **메트릭 수집**: 개발 시간, 버그 발생률, 성능 지표 추적
- **베스트 프랙티스 업데이트**: 새로운 패턴 발견 시 규칙 업데이트
- **도구 개선**: 개발 효율성 향상을 위한 도구 및 자동화 개선

---

## 📚 관련 Rules
- [1001-fsd-architecture](mdc:.cursor/rules/1001-fsd-architecture.mdc): FSD 아키텍처 상세 가이드
- [1002-tech-stack](mdc:.cursor/rules/1002-tech-stack.mdc): 기술 스택 및 개발 패턴
- [1003-implementation-patterns](mdc:.cursor/rules/1003-implementation-patterns.mdc): 구현 패턴 및 예시
