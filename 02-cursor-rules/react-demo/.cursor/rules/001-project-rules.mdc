---
globs: **/with-rules/**
alwaysApply: false
---
# 상품 검색 데모 - Cursor Rules

## 개발 프로세스 (중요)

### 1단계: 계획 모드 (기본)
- 모든 기능 요청에 대해 계획 모드로 시작하기
- 요구사항에 대한 명확한 질문하기
- 컴포넌트 구조와 데이터 흐름 논의하기
- 잠재적 문제점과 해결방안 파악하기
- 폴더 구조와 파일 구성 제안하기
- 사용자가 명시적으로 "실행해줘", "act", "구현해줘"라고 말할 때까지 계획 지속하기
- 계획 단계에서는 실제 코드 작성하지 않기
- 아키텍처, 컴포넌트 분해, 설계 결정에 집중하기

### 2단계: 실행 모드 (구현)
- "실행해줘", "act", "구현해줘", "만들어줘", "코딩 시작해줘" 키워드로만 구현 시작
- 계획된 아키텍처를 정확히 따르기
- 적절한 에러 핸들링이 포함된 완성도 높은 코드 작성하기
- 계획된 모든 컴포넌트를 체계적으로 구현하기

## 기술 스택

### 필수 라이브러리
- React 18 + TypeScript (strict 모드)
- Tailwind CSS (스타일링)
- shadcn/ui (UI 컴포넌트)
- TanStack Query (서버 상태 관리)
- Zustand (클라이언트 상태 관리)
- Zod (런타임 타입 검증 및 스키마)

### 프로젝트 구조
```
react-demo/
├── src/
│   ├── pages/
│   │   ├── with-rules/
│   │   │   └── index.tsx
│   │   └── without-rules/
│   │       └── index.tsx
│   ├── data/               # 공통 목 데이터 (양쪽에서 접근)
│   │   └── sampleProduct.ts
│   ├── with-rules/         # FSD 패턴 적용된 구조
│   │   ├── app/            # 애플리케이션 설정
│   │   ├── pages/          # 페이지 레벨 컴포넌트
│   │   ├── widgets/        # 복잡한 UI 블록
│   │   ├── features/       # 비즈니스 기능
│   │   ├── entities/       # 비즈니스 엔티티
│   │   └── shared/         # 공통 유틸리티와 UI
│   ├── without-rules/      # Rules 미적용 구조 (기본 React 패턴)
│   │   ├── components/     # 기본 컴포넌트들 (구조화 안됨)
│   │   ├── hooks/          # 기본 훅들
│   │   ├── types/          # 기본 타입들
│   │   └── utils/          # 기본 유틸들
│   └── App.tsx
```

## 컴포넌트 설계 원칙

### 단일 책임 원칙 (필수)
- 각 컴포넌트는 하나의 명확한 목적만 가져야 함
- 복잡한 컴포넌트는 더 작고 집중된 컴포넌트들로 분해하기
- 예시:
  - ❌ ProductSearchPage (검색, 필터, 표시, 페이지네이션 모두 처리)
  - ✅ SearchInput, FilterPanel, ProductGrid, Pagination (각각 분리된 컴포넌트)

### FSD 패턴 레이어 구조
1. **App 레이어** (`app/`)
   - 애플리케이션 초기화
   - 전역 프로바이더와 라우팅
   - 설정 파일들

2. **Pages 레이어** (`pages/`)
   - 라우트 레벨 컴포넌트들
   - 페이지 구성과 조합
   - 각 페이지의 메인 컨테이너

3. **Widgets 레이어** (`widgets/`)
   - 복잡한 UI 블록들
   - 여러 기능을 조합한 복합 컴포넌트들
   - 독립적으로 동작하는 UI 단위

4. **Features 레이어** (`features/`)
   - 비즈니스 로직과 사용자 상호작용
   - 특정 기능별 컴포넌트들
   - 상태 관리와 비즈니스 로직 포함

5. **Entities 레이어** (`entities/`)
   - 비즈니스 엔티티와 관련 로직
   - 데이터 모델과 스키마
   - 엔티티별 API 호출 로직

6. **Shared 레이어** (`shared/`)
   - 재사용 가능한 유틸리티, UI 킷
   - 공통 인프라스트럭처
   - shadcn/ui 컴포넌트들과 공통 훅들

### 컴포넌트 구조 템플릿
```typescript
// 1. 외부 라이브러리, 내부 라이브러리, 타입 순으로 import
// 2. 타입 정의 (Props 인터페이스)
// 3. 컴포넌트 구현
// 4. Default export

interface ComponentNameProps {
  // 엄격한 타이핑 필수
}

const ComponentName: React.FC<ComponentNameProps> = ({ ...props }) => {
  // 컴포넌트 로직
  return (
    // Tailwind 클래스와 함께 JSX
  );
};

export default ComponentName;
```

## TypeScript 규칙

### 엄격한 타입 안전성
- tsconfig.json에서 strict 모드 활성화
- `any` 타입 사용 금지
- 알 수 없는 데이터에는 `object`보다 `unknown` 사용
- 느슨한 타이핑보다 타입 유니온 선호
- 재사용 가능한 컴포넌트에는 제네릭 타입 사용

### Zod 통합
- 모든 외부 데이터에 대해 Zod 스키마 생성
- TypeScript 타입 도출을 위해 `z.infer<>` 사용
- API 응답과 폼 입력 검증
- 스키마들을 `schemas/` 디렉토리에 배치

### 타입 구성 (entities 레이어에 배치)
```typescript
// entities/product/model/types.ts
import { z } from 'zod';

export const ProductSchema = z.object({
  id: z.string(),
  name: z.string(),
  price: z.number().positive(),
  category: z.string(),
  inStock: z.boolean(),
});

export type Product = z.infer<typeof ProductSchema>;

// API 응답 타입들
export const ProductListResponseSchema = z.object({
  products: z.array(ProductSchema),
  total: z.number(),
  page: z.number(),
});

export type ProductListResponse = z.infer<typeof ProductListResponseSchema>;
```

## 상태 관리

### Zustand 스토어 구조 (features 레이어에 배치)
- 도메인별로 별도 스토어 생성
- Zustand와 TypeScript 함께 사용
- `features/{feature-name}/model/` 디렉토리에 스토어 구현
- 큰 스토어에는 slice 패턴 따르기

```typescript
// features/product-search/model/productStore.ts
interface ProductStore {
  // 상태
  searchTerm: string;
  filters: ProductFilters;
  
  // 액션들
  setSearchTerm: (term: string) => void;
  updateFilters: (filters: Partial<ProductFilters>) => void;
  resetFilters: () => void;
}
```

### TanStack Query 통합 (entities 레이어에 배치)
- `entities/{entity-name}/api/`에 쿼리 훅 생성
- 적절한 에러 핸들링과 로딩 상태 사용
- 적절한 곳에 낙관적 업데이트 구현
- 적절한 키로 캐시 관리

## 스타일링 규칙

### Tailwind CSS 가이드라인
- Tailwind 유틸리티 클래스만 사용
- 절대 필요한 경우가 아니면 커스텀 CSS 사용 금지
- 모바일 우선 반응형 디자인 따르기
- 일관된 spacing 스케일 사용 (4, 8, 12, 16, 24, 32, 48, 64)

### shadcn/ui 통합
- shadcn/ui 컴포넌트를 기본으로 사용
- Tailwind 클래스로 커스터마이징
- 디자인 시스템 일관성 유지
- 컴포넌트 props에서 variant 조합 생성

### 반응형 디자인
- 모바일 우선 접근법 (모바일용 기본 스타일)
- Tailwind 반응형 접두사 사용 (sm:, md:, lg:, xl:)
- 여러 화면 크기에서 테스트
- 터치 친화적 인터페이스 보장

## 파일 명명과 구성

### 명명 규칙
- **컴포넌트**: PascalCase (ProductCard.tsx)
- **훅**: 'use' 접두사와 camelCase (useProductQuery.ts)
- **스토어**: 'Store' 접미사와 camelCase (productStore.ts)
- **타입**: PascalCase (ProductFilters)
- **상수**: SCREAMING_SNAKE_CASE
- **디렉토리**: kebab-case

### Import 구성 (FSD 패턴 기준)
```typescript
// 1. 외부 라이브러리들
import React from 'react';
import { useQuery } from '@tanstack/react-query';

// 2. Shared 레이어 (공통 유틸리티)
import { Button } from '@/shared/ui/button';

// 3. Entities 레이어 (비즈니스 엔티티)
import { useProductStore } from '@/entities/product/model/productStore';
import type { Product } from '@/entities/product/model/types';

// 4. Features 레이어 (비즈니스 기능)
import { ProductFilters } from '@/features/product-search/ui/ProductFilters';

// 5. 같은 레이어 내 컴포넌트들
import ProductCard from './ProductCard';
```

## 성능 최적화

### React 최적화
- 비용이 많이 드는 순수 컴포넌트에 React.memo 사용
- 무거운 계산에 useMemo 구현
- 안정적인 참조를 위해 useCallback 사용
- 적절한 의존성 배열로 재렌더링 최적화

## 구현 가이드라인

### 개발 워크플로우
1. **계획 단계**: 아키텍처 논의하고 요구사항 분해하기
2. **스키마 정의**: Zod 스키마와 TypeScript 타입 정의하기
3. **스토어 설정**: 필요한 Zustand 스토어들 생성하기
4. **컴포넌트 구조**: 컴포넌트 계층 구조 만들기
5. **UI 구현**: shadcn/ui와 Tailwind로 구현하기
6. **통합**: 컴포넌트들을 스토어와 쿼리와 연결하기

## 단계 전환 키워드
- **계획 모드 유지**: 이런 키워드들 없이 계속 논의
- **구현 모드로 전환**: "실행해줘", "act", "구현해줘", "만들어줘", "코딩 시작해줘", "해보자"

기억하기: 구현하기 전에 항상 계획 모드로 시작해서 접근법을 철저히 논의하기!